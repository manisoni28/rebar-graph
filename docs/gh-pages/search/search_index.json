{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rebar is a discovery tool that builds a graph model of your cloud infrastructure. Rebar integrates with your infrastructure control plane to extract important metadata, which it then replicates into a graph database. Rationale Most commercial software deployments are heterogenous in nature. Your infrastructure is likely spread across cloud-providers, split into multiple accounts, spread across multiple regions and serving multiple environments. Some may be containerized, some may not. Some may be running in Kubernetes and some may not. If you are running Kubernetes, you probably have a number of clusters.","title":"Overview"},{"location":"#rationale","text":"Most commercial software deployments are heterogenous in nature. Your infrastructure is likely spread across cloud-providers, split into multiple accounts, spread across multiple regions and serving multiple environments. Some may be containerized, some may not. Some may be running in Kubernetes and some may not. If you are running Kubernetes, you probably have a number of clusters.","title":"Rationale"},{"location":"architecture/","text":"See FAQ until this is written.","title":"Architecture"},{"location":"aws-model/","text":"Data Model AwsAccount Name Type Description account string AWS Account that owns this Account graphEntityGroup string always aws graphEntityType string always AwsAccount graphUpdateTs number last time graph node was updated (millis since epoch) AwsAsg Name Type Description account string AWS Account that owns this Asg arn string Amazon Resource Name (ARN) of the Asg name string name of the Asg (qualified by region and account ) region string Region ( us-east-1 , us-west-2 , etc) autoScalingGroupARN string autoScalingGroupName string availabilityZones array createdTime number defaultCooldown number desiredCapacity number enabledMetrics array graphEntityGroup string always aws graphEntityType string always AwsAsg graphUpdateTs number last time graph node was updated (millis since epoch) healthCheckGracePeriod number healthCheckType string instances array launchTemplateId string launchTemplateName string launchTemplateVersion string loadBalancerNames array maxSize number minSize number newInstancesProtectedFromScaleIn boolean serviceLinkedRoleARN string suspendedProcesses array tags array targetGroupARNs array terminationPolicies array vpczoneIdentifier string AwsAvailabilityZone Name Type Description name string name of the AvailabilityZone (qualified by region and account ) region string Region ( us-east-1 , us-west-2 , etc) graphEntityGroup string always aws graphEntityType string always AwsAvailabilityZone graphUpdateTs number last time graph node was updated (millis since epoch) AwsEc2Instance Name Type Description account string AWS Account that owns this Ec2Instance arn string Amazon Resource Name (ARN) of the Ec2Instance region string Region ( us-east-1 , us-west-2 , etc) amiLaunchIndex number architecture string clientToken string ebsOptimized boolean elasticGpuAssociations array enaSupport boolean graphEntityGroup string always aws graphEntityType string always AwsEc2Instance graphUpdateTs number last time graph node was updated (millis since epoch) hypervisor string imageId string instanceId string instanceType string keyName string launchTime number privateDnsName string privateIpAddress string publicDnsName string publicIpAddress string reservationId string reservationOwnerId string reservationRequesterId string rootDeviceName string rootDeviceType string sourceDestCheck boolean stateCode number stateName string stateTransitionReason string subnetId string virtualizationType string vpcId string AwsLambdaFunction Name Type Description account string AWS Account that owns this LambdaFunction arn string Amazon Resource Name (ARN) of the LambdaFunction name string name of the LambdaFunction (qualified by region and account ) region string Region ( us-east-1 , us-west-2 , etc) codeSha256 string codeSize number description string functionArn string functionName string graphEntityGroup string always aws graphEntityType string always AwsLambdaFunction graphUpdateTs number last time graph node was updated (millis since epoch) handler string lastModified string memorySize number revisionId string role string runtime string timeout number tracingConfigMode string version string vpcId string vpcSubnetIds array AwsLaunchTemplate Name Type Description account string AWS Account that owns this LaunchTemplate arn string Amazon Resource Name (ARN) of the LaunchTemplate name string name of the LaunchTemplate (qualified by region and account ) region string Region ( us-east-1 , us-west-2 , etc) createTime number createdBy string defaultVersionNumber number graphEntityGroup string always aws graphEntityType string always AwsLaunchTemplate graphUpdateTs number last time graph node was updated (millis since epoch) latestVersionNumber number launchTemplateId string launchTemplateName string tags array AwsRegion Name Type Description region string Region ( us-east-1 , us-west-2 , etc) graphEntityGroup string always aws graphEntityType string always AwsRegion graphUpdateTs number last time graph node was updated (millis since epoch) AwsSecurityGroup Name Type Description account string AWS Account that owns this SecurityGroup arn string Amazon Resource Name (ARN) of the SecurityGroup name string name of the SecurityGroup (qualified by region and account ) region string Region ( us-east-1 , us-west-2 , etc) description string graphEntityGroup string always aws graphEntityType string always AwsSecurityGroup graphUpdateTs number last time graph node was updated (millis since epoch) groupId string groupName string ipPermissionsEgress array ownerId string tags array vpcId string AwsSubnet Name Type Description account string AWS Account that owns this Subnet arn string Amazon Resource Name (ARN) of the Subnet region string Region ( us-east-1 , us-west-2 , etc) assignIpv6AddressOnCreation boolean availabilityZone string availableIpAddressCount number cidrBlock string defaultForAz boolean graphEntityGroup string always aws graphEntityType string always AwsSubnet graphUpdateTs number last time graph node was updated (millis since epoch) ipv6CidrBlockAssociationSet array mapPublicIpOnLaunch boolean state string subnetId string vpcId string AwsVpc Name Type Description account string AWS Account that owns this Vpc arn string Amazon Resource Name (ARN) of the Vpc region string Region ( us-east-1 , us-west-2 , etc) cidrBlock string default boolean dhcpOptionsId string graphEntityGroup string always aws graphEntityType string always AwsVpc graphUpdateTs number last time graph node was updated (millis since epoch) instanceTenancy string ipv6CidrBlockAssociationSet array isDefault boolean state string vpcId string Other","title":"AWS Data Model"},{"location":"aws-model/#data-model","text":"","title":"Data Model"},{"location":"aws-model/#awsaccount","text":"Name Type Description account string AWS Account that owns this Account graphEntityGroup string always aws graphEntityType string always AwsAccount graphUpdateTs number last time graph node was updated (millis since epoch)","title":"AwsAccount"},{"location":"aws-model/#awsasg","text":"Name Type Description account string AWS Account that owns this Asg arn string Amazon Resource Name (ARN) of the Asg name string name of the Asg (qualified by region and account ) region string Region ( us-east-1 , us-west-2 , etc) autoScalingGroupARN string autoScalingGroupName string availabilityZones array createdTime number defaultCooldown number desiredCapacity number enabledMetrics array graphEntityGroup string always aws graphEntityType string always AwsAsg graphUpdateTs number last time graph node was updated (millis since epoch) healthCheckGracePeriod number healthCheckType string instances array launchTemplateId string launchTemplateName string launchTemplateVersion string loadBalancerNames array maxSize number minSize number newInstancesProtectedFromScaleIn boolean serviceLinkedRoleARN string suspendedProcesses array tags array targetGroupARNs array terminationPolicies array vpczoneIdentifier string","title":"AwsAsg"},{"location":"aws-model/#awsavailabilityzone","text":"Name Type Description name string name of the AvailabilityZone (qualified by region and account ) region string Region ( us-east-1 , us-west-2 , etc) graphEntityGroup string always aws graphEntityType string always AwsAvailabilityZone graphUpdateTs number last time graph node was updated (millis since epoch)","title":"AwsAvailabilityZone"},{"location":"aws-model/#awsec2instance","text":"Name Type Description account string AWS Account that owns this Ec2Instance arn string Amazon Resource Name (ARN) of the Ec2Instance region string Region ( us-east-1 , us-west-2 , etc) amiLaunchIndex number architecture string clientToken string ebsOptimized boolean elasticGpuAssociations array enaSupport boolean graphEntityGroup string always aws graphEntityType string always AwsEc2Instance graphUpdateTs number last time graph node was updated (millis since epoch) hypervisor string imageId string instanceId string instanceType string keyName string launchTime number privateDnsName string privateIpAddress string publicDnsName string publicIpAddress string reservationId string reservationOwnerId string reservationRequesterId string rootDeviceName string rootDeviceType string sourceDestCheck boolean stateCode number stateName string stateTransitionReason string subnetId string virtualizationType string vpcId string","title":"AwsEc2Instance"},{"location":"aws-model/#awslambdafunction","text":"Name Type Description account string AWS Account that owns this LambdaFunction arn string Amazon Resource Name (ARN) of the LambdaFunction name string name of the LambdaFunction (qualified by region and account ) region string Region ( us-east-1 , us-west-2 , etc) codeSha256 string codeSize number description string functionArn string functionName string graphEntityGroup string always aws graphEntityType string always AwsLambdaFunction graphUpdateTs number last time graph node was updated (millis since epoch) handler string lastModified string memorySize number revisionId string role string runtime string timeout number tracingConfigMode string version string vpcId string vpcSubnetIds array","title":"AwsLambdaFunction"},{"location":"aws-model/#awslaunchtemplate","text":"Name Type Description account string AWS Account that owns this LaunchTemplate arn string Amazon Resource Name (ARN) of the LaunchTemplate name string name of the LaunchTemplate (qualified by region and account ) region string Region ( us-east-1 , us-west-2 , etc) createTime number createdBy string defaultVersionNumber number graphEntityGroup string always aws graphEntityType string always AwsLaunchTemplate graphUpdateTs number last time graph node was updated (millis since epoch) latestVersionNumber number launchTemplateId string launchTemplateName string tags array","title":"AwsLaunchTemplate"},{"location":"aws-model/#awsregion","text":"Name Type Description region string Region ( us-east-1 , us-west-2 , etc) graphEntityGroup string always aws graphEntityType string always AwsRegion graphUpdateTs number last time graph node was updated (millis since epoch)","title":"AwsRegion"},{"location":"aws-model/#awssecuritygroup","text":"Name Type Description account string AWS Account that owns this SecurityGroup arn string Amazon Resource Name (ARN) of the SecurityGroup name string name of the SecurityGroup (qualified by region and account ) region string Region ( us-east-1 , us-west-2 , etc) description string graphEntityGroup string always aws graphEntityType string always AwsSecurityGroup graphUpdateTs number last time graph node was updated (millis since epoch) groupId string groupName string ipPermissionsEgress array ownerId string tags array vpcId string","title":"AwsSecurityGroup"},{"location":"aws-model/#awssubnet","text":"Name Type Description account string AWS Account that owns this Subnet arn string Amazon Resource Name (ARN) of the Subnet region string Region ( us-east-1 , us-west-2 , etc) assignIpv6AddressOnCreation boolean availabilityZone string availableIpAddressCount number cidrBlock string defaultForAz boolean graphEntityGroup string always aws graphEntityType string always AwsSubnet graphUpdateTs number last time graph node was updated (millis since epoch) ipv6CidrBlockAssociationSet array mapPublicIpOnLaunch boolean state string subnetId string vpcId string","title":"AwsSubnet"},{"location":"aws-model/#awsvpc","text":"Name Type Description account string AWS Account that owns this Vpc arn string Amazon Resource Name (ARN) of the Vpc region string Region ( us-east-1 , us-west-2 , etc) cidrBlock string default boolean dhcpOptionsId string graphEntityGroup string always aws graphEntityType string always AwsVpc graphUpdateTs number last time graph node was updated (millis since epoch) instanceTenancy string ipv6CidrBlockAssociationSet array isDefault boolean state string vpcId string","title":"AwsVpc"},{"location":"aws-model/#other","text":"","title":"Other"},{"location":"aws/","text":"Builds graph model of AWS infrastructure. Getting Started You will need a neo4j graph database instance to store the data that rebar will gather from AWS. Assuming you don't have a neo4j instance you will want to start one by running the following: docker run \\ -it --rm \\ --publish = 7474 :7474 --publish = 7687 :7687 \\ --env = NEO4J_ACCEPT_LICENSE_AGREEMENT = yes \\ --env = NEO4J_AUTH = none \\ --name = neo4j \\ neo4j:3.4 After Neo4j has started, you can access the console in your browser: http://localhost:7474 Now you can run aws-scanner : docker run -it \\ -e GRAPH_URL=bolt://host.docker.internal:7687 \\ -v $HOME/.aws:/rebar/.aws:ro \\ rebar/aws-scanner Note: if you need to set username/password, they should be set with the environment variables: GRAPH_USERNAME and GRAPH_PASSWORD . For this to work, you need valid AWS credentials in $HOME/.aws . Note also that host.docker.internal only works on Docker for Mac/Windows. For Linux, you would need to provide the host IP in the GRAPH_URL environment variables. Once this has run, you can enter a Cypher query in the Neo4j console to see the graph: The following will display the entire graph match (a) return a; Configuration The following options can be passed as environment variables. Env Variable Required? Description Example GRAPH_URL Required URL of Graph Database bolt://myserver:7687 GRAPH_USERNAME - Database username GRAPH_PASSWORD - Database password AWS_REGIONS - Comma-seaparated list of regions to be scanned. If omitted, only the \"current\" region will be scanned. us-east , us-west-2 Supported Types Type Status Notes AwsRegion \u2705 AwsAvailabilityZone \u2705 AwsAccount \u2705 AwsVpc \u2705 AwsSubnet \u2705 AwsSecurityGroup \u2705 AwsAsg \u2705 AwsElb \u2705 Classic, Network, and Application AwsEc2Instance \u2705 AwsLaunchConfig \u2705 AwsLaunchTemplate \u2705 AwsAmi \u2705 AwsS3Bucket \u2705 AwsEksCluster \u2705 AwsRdsCluster \u2705 AwsRdsInstance \u2705 AwsRoute53RecordSet \u2705 AwsRoute53HostedZone \u2705 AwsTargetGroup \u2705 AwsSqsQueue \u2705 AwsSnsTopic \u2705 AwsSnsSubscription \u2705 AwsSes \u26d4 AwsGlue \u26d4 AwsKinesisStream \u26d4 AwsRouteTable \u26d4 AwsVpnGateway \u2705 AwsVpcPeeringConnection \u2705 AwsVpcEndpoint \u2705 AwsInternetGateway \u2705 AwsEgressOnlyInternetGateway \u2705 AwsIamUser \u26d4 AwsIamInlinePolicy \u26d4 AwsIamRole \u26d4 AwsIamPolicy \u26d4 AwsIamManagedPolicy \u26d4 AwsEc2NetworkInterface \u26d4 AwsEcrRepository \u26d4 AwsDynamoDbTable \u26d4 Naming Conventions Entity and Attributes All AWS entities should begin with Aws . For example AwsAccount , AwsRegion , AwsEc2Instance , etc. All AWS nodes should have a region attribute. The values of region should be the lower case region names: us-east-1 , us-west-2 , etc. All attributes should use lower camel case. arn should use used wherever possible. ARN's are globally unique. Names are typically unique only by account - region pairs. IDs tend to be region -unique, but have no guarantees of uniqueness across regions. Unique index for arn should be created if arn attribute is used. All AWS nodes should have graphEntityType set to the label of the node and graphEntityGroup = aws . The graphEntityType property makes it easier for the code to know what kind of node it is using. Be very careful to qualify all non-unique attributes by account and region . For instance, if you are looking up or modifiying an AwsElb , with {name:'foo'} , be aware that this could match an ELB in any account or region. It should be restricted with addition pattern matching attributes: {name:'foo', account:'1111111111', region:'us-east-1} The jackson Object-to-Json converter is used for most of the JSON serialization. The AWS Java classes are auto-generated by Amazon in the SDK from the API specification. This is a somewhat indirect representation of the underlying API, but in practice it works very well. Relationships Create only directed relationships. Use active verb relationship names where possible. Passive relationship names are OK when the active direction doesn't make a lot of sense. When things contain other things, use the relationship name HAS When an entity makes reference to another entity, but doesn't \"own\" it: USES or ATTACHED_TO . For instance, (e:AwsEc2Instance)-[USES]- (s:AwsSecurityGroup) DO NOT create relationships to AwsRegion . It results in a super-node with very little practical benefit. DO NOT create relationships to AwsAccount if there are other transitive ways to reach account. For instance, anything that is related to a AwsVpc doesn't need its own relationship to AwsAccount , since it can be derived transitively and every object already has an account label. However, AwsS3Bucket and AwsRdsCluster does not belong to a VPC, so it should have a relationship to account. (Note: At some point in the future, I may consider changing this policy and mandating that everything has a relationship to AwsAccount . However, I have no plans to do so yet.) Writing an AWS Scanner First, understand that the AWS APIs are charmingly inconsistent . They are clearly all written by the same company and are mostly consistent with naming and such. However there is a lot of subtle variation, including: Some APIs use pagination. Some don't. The tokens that they use for pagination have different names. Some refer to their entities by ARN. Others by id. Others by name. Exceptions and behavior for entities that aren't found varies widely. Performance varies widely across APIs. Some hit rate limits easily. Others don't. etc. We are able to eliminate a lot of boilerplate from the scanners, but a fair amount remains. All AWS scanners should all extend AwsEntityScanner T where T is the type of the primary entity that they handle. AwsEntityScanner instances are locked to an account-region pair. The underlying AwsScanner takes care of sharing client connections. In general you shoud simply call AwsEntityScanner.getClient( ) to get an AWS client of your choice. All scanners need to reference a AwsEntityType enum type. For instance AwsEc2Instance , AwsVpc , etc. In general, doScan() should keep going when exceptions are encountered. It is encouraged to use tryExecute() to handle exceptions correctly as it loops through returned items. When single entities are scanned, exceptions shoud NOT be caught. The thinking here, is that if you are scanning a specific item and it fails, you probably want to know. However, if you are scanning a whole account-region , you want as much of the data as possible. It is reccommended to use the GraphDB DSL for most graph mutations rather than writing cypher directly. It eliminates a lot of error-prone boilerplate. Dealing With Deletion Dealing with deleted items is one of the tricker parts of maintaining the graph. What has worked best is a 2-phase operation. When a full scan of a given type in an account-region tuple is complete, there is code that loads all the entities for that type for that given account-region pair. We then look at the timestmp of each node that was loaded. If graphUpdateTs is less than the start time of the operation, we know that the entity may have been deleted. To find out if the entity has been deleted or not, we need to make a single get or describe operation for that entity. If AWS responds definitively that the item does not exist, we are free to delete it from the graph. There is some complexity with the mutli-tenant data mdoel. We need to make sure that we are only operating on items from the account-region tuple that our scanner is configured to use. Calling describe or get on an enitity from another account or region would cause AWS to return with some vaiant of NotFound , which we might cause us to delete an entitiy in our account-region .","title":"AWS Scanner"},{"location":"aws/#getting-started","text":"You will need a neo4j graph database instance to store the data that rebar will gather from AWS. Assuming you don't have a neo4j instance you will want to start one by running the following: docker run \\ -it --rm \\ --publish = 7474 :7474 --publish = 7687 :7687 \\ --env = NEO4J_ACCEPT_LICENSE_AGREEMENT = yes \\ --env = NEO4J_AUTH = none \\ --name = neo4j \\ neo4j:3.4 After Neo4j has started, you can access the console in your browser: http://localhost:7474 Now you can run aws-scanner : docker run -it \\ -e GRAPH_URL=bolt://host.docker.internal:7687 \\ -v $HOME/.aws:/rebar/.aws:ro \\ rebar/aws-scanner Note: if you need to set username/password, they should be set with the environment variables: GRAPH_USERNAME and GRAPH_PASSWORD . For this to work, you need valid AWS credentials in $HOME/.aws . Note also that host.docker.internal only works on Docker for Mac/Windows. For Linux, you would need to provide the host IP in the GRAPH_URL environment variables. Once this has run, you can enter a Cypher query in the Neo4j console to see the graph: The following will display the entire graph match (a) return a;","title":"Getting Started"},{"location":"aws/#configuration","text":"The following options can be passed as environment variables. Env Variable Required? Description Example GRAPH_URL Required URL of Graph Database bolt://myserver:7687 GRAPH_USERNAME - Database username GRAPH_PASSWORD - Database password AWS_REGIONS - Comma-seaparated list of regions to be scanned. If omitted, only the \"current\" region will be scanned. us-east , us-west-2","title":"Configuration"},{"location":"aws/#supported-types","text":"Type Status Notes AwsRegion \u2705 AwsAvailabilityZone \u2705 AwsAccount \u2705 AwsVpc \u2705 AwsSubnet \u2705 AwsSecurityGroup \u2705 AwsAsg \u2705 AwsElb \u2705 Classic, Network, and Application AwsEc2Instance \u2705 AwsLaunchConfig \u2705 AwsLaunchTemplate \u2705 AwsAmi \u2705 AwsS3Bucket \u2705 AwsEksCluster \u2705 AwsRdsCluster \u2705 AwsRdsInstance \u2705 AwsRoute53RecordSet \u2705 AwsRoute53HostedZone \u2705 AwsTargetGroup \u2705 AwsSqsQueue \u2705 AwsSnsTopic \u2705 AwsSnsSubscription \u2705 AwsSes \u26d4 AwsGlue \u26d4 AwsKinesisStream \u26d4 AwsRouteTable \u26d4 AwsVpnGateway \u2705 AwsVpcPeeringConnection \u2705 AwsVpcEndpoint \u2705 AwsInternetGateway \u2705 AwsEgressOnlyInternetGateway \u2705 AwsIamUser \u26d4 AwsIamInlinePolicy \u26d4 AwsIamRole \u26d4 AwsIamPolicy \u26d4 AwsIamManagedPolicy \u26d4 AwsEc2NetworkInterface \u26d4 AwsEcrRepository \u26d4 AwsDynamoDbTable \u26d4","title":"Supported Types"},{"location":"aws/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"aws/#entity-and-attributes","text":"All AWS entities should begin with Aws . For example AwsAccount , AwsRegion , AwsEc2Instance , etc. All AWS nodes should have a region attribute. The values of region should be the lower case region names: us-east-1 , us-west-2 , etc. All attributes should use lower camel case. arn should use used wherever possible. ARN's are globally unique. Names are typically unique only by account - region pairs. IDs tend to be region -unique, but have no guarantees of uniqueness across regions. Unique index for arn should be created if arn attribute is used. All AWS nodes should have graphEntityType set to the label of the node and graphEntityGroup = aws . The graphEntityType property makes it easier for the code to know what kind of node it is using. Be very careful to qualify all non-unique attributes by account and region . For instance, if you are looking up or modifiying an AwsElb , with {name:'foo'} , be aware that this could match an ELB in any account or region. It should be restricted with addition pattern matching attributes: {name:'foo', account:'1111111111', region:'us-east-1} The jackson Object-to-Json converter is used for most of the JSON serialization. The AWS Java classes are auto-generated by Amazon in the SDK from the API specification. This is a somewhat indirect representation of the underlying API, but in practice it works very well.","title":"Entity and Attributes"},{"location":"aws/#relationships","text":"Create only directed relationships. Use active verb relationship names where possible. Passive relationship names are OK when the active direction doesn't make a lot of sense. When things contain other things, use the relationship name HAS When an entity makes reference to another entity, but doesn't \"own\" it: USES or ATTACHED_TO . For instance, (e:AwsEc2Instance)-[USES]- (s:AwsSecurityGroup) DO NOT create relationships to AwsRegion . It results in a super-node with very little practical benefit. DO NOT create relationships to AwsAccount if there are other transitive ways to reach account. For instance, anything that is related to a AwsVpc doesn't need its own relationship to AwsAccount , since it can be derived transitively and every object already has an account label. However, AwsS3Bucket and AwsRdsCluster does not belong to a VPC, so it should have a relationship to account. (Note: At some point in the future, I may consider changing this policy and mandating that everything has a relationship to AwsAccount . However, I have no plans to do so yet.)","title":"Relationships"},{"location":"aws/#writing-an-aws-scanner","text":"First, understand that the AWS APIs are charmingly inconsistent . They are clearly all written by the same company and are mostly consistent with naming and such. However there is a lot of subtle variation, including: Some APIs use pagination. Some don't. The tokens that they use for pagination have different names. Some refer to their entities by ARN. Others by id. Others by name. Exceptions and behavior for entities that aren't found varies widely. Performance varies widely across APIs. Some hit rate limits easily. Others don't. etc. We are able to eliminate a lot of boilerplate from the scanners, but a fair amount remains. All AWS scanners should all extend AwsEntityScanner T where T is the type of the primary entity that they handle. AwsEntityScanner instances are locked to an account-region pair. The underlying AwsScanner takes care of sharing client connections. In general you shoud simply call AwsEntityScanner.getClient( ) to get an AWS client of your choice. All scanners need to reference a AwsEntityType enum type. For instance AwsEc2Instance , AwsVpc , etc. In general, doScan() should keep going when exceptions are encountered. It is encouraged to use tryExecute() to handle exceptions correctly as it loops through returned items. When single entities are scanned, exceptions shoud NOT be caught. The thinking here, is that if you are scanning a specific item and it fails, you probably want to know. However, if you are scanning a whole account-region , you want as much of the data as possible. It is reccommended to use the GraphDB DSL for most graph mutations rather than writing cypher directly. It eliminates a lot of error-prone boilerplate.","title":"Writing an AWS Scanner"},{"location":"aws/#dealing-with-deletion","text":"Dealing with deleted items is one of the tricker parts of maintaining the graph. What has worked best is a 2-phase operation. When a full scan of a given type in an account-region tuple is complete, there is code that loads all the entities for that type for that given account-region pair. We then look at the timestmp of each node that was loaded. If graphUpdateTs is less than the start time of the operation, we know that the entity may have been deleted. To find out if the entity has been deleted or not, we need to make a single get or describe operation for that entity. If AWS responds definitively that the item does not exist, we are free to delete it from the graph. There is some complexity with the mutli-tenant data mdoel. We need to make sure that we are only operating on items from the account-region tuple that our scanner is configured to use. Calling describe or get on an enitity from another account or region would cause AWS to return with some vaiant of NotFound , which we might cause us to delete an entitiy in our account-region .","title":"Dealing With Deletion"},{"location":"faq/","text":"Is Rebar a framework? No. Rebar is unopinionated about how you design, build and operate your systems. It is designed to be added to your infrastructure without need for structural modification. Is it a Platform-as-a-Service? No. At my previous employer we did build a PaaS on top of this architecture and this worked very well. However, Rebar is not a PaaS. Use your own PaaS, CloudFoundry, whatever. We are pretty sure that not ALL of your infrastructure will be in the PaaS though. Is it an asset management / discovery tool? Asset management tools suck. When developers hear the words asset management they flee. Rebar is fun and cool. Rebar does do many of the things that asset management tools do but it is shiny new and modern and your dev team will love working with it. Why do I need this graph data model when there is an API for everything? It is a good question. At small scale, tying things together with API calls works fine. But as soon as your infrastructure has enough dimensions (enivronments, teams, providers, services, etc.) even seemingly simple tasks can start to get quite complicated. I want to deploy a new version of XYZ to https://cool.example.com, but what account/region is it in? Which ELB handles it? Yes, these answers can be had with API calls. But in practice, it is surprisingly difficult. You start running into N^2 problems and/or running up against mundane problems like managing auth credentials for all your tools/scripts. Things become just difficult enough that neglect sets in. On the other hand, if you can get a real-time answer with a simple query against a graph database, problems that might have been daunting can seem almost effortless (and fun). I'm using AWS/GCP/Azure, why would I need this? Your infrastructure is likely spread across many accounts and segmented into regions. Cloud providers do this to maximize availability and isolate regions into idependent failure domains. However, that comes at a cost of significant management complexity. You think you have infrastructure running in us-east-1 and us-west-2 . But do you have anything in eu-west-2 ? Are you sure? Does XYZ run in GCP or AWS or both? These are the kind of simple questions that can be quite time consuming to answer. With Rebar, they are simple. To cite a simple example, in our experience, cloud providers tend to send notifications about infrastructure without much context. The following is common: \"Thanks for telling me that i-ab38d8273ff4 is about to die. But what account is it in? What region? What is it for? Who is responsible for it? What will happen when it is terminated?\" You're on your own. Easy to automate? Yes. But will you? Probably not. I'm using Terraform/CloudFormation/etc, why would I need this? I'm going to take wild guess and say that only some subset of your infrastructure is actually managed by Terraform or CloudFormation or whatever your management tool of choice. But which services are using them correctly? Which aren't? These are the questions we can answer quickly and easily with Rebar. Besides, how many people in your org actually understand that Terraform / CloudFormation you wrote? I'll be that it is a lot fewer than you think. I'm using Kubernetes, why would I need this? First, if you are running anything more than a PoC, you probably have a few Kubernetes clusters. You might have some OpenShift on-prem and some EKS clusters spread across accounts and regions. If you want find all the services that are using an image with a critical CVE, how are you going to do that without going on a spelunking exercise? Again, it is not that it is a hard problem to solve. In our experience, you just won't prioritize it, so you die a slow death of 1000 cuts. Rebar fixes this. But I have Chef/Puppet/Ansible/Salt, why would I need this? That's funny. In our experience, we needed Rebar just to figure out whether those tools were deployed and working correctly.","title":"FAQ"},{"location":"faq/#is-rebar-a-framework","text":"No. Rebar is unopinionated about how you design, build and operate your systems. It is designed to be added to your infrastructure without need for structural modification.","title":"Is Rebar a framework?"},{"location":"faq/#is-it-a-platform-as-a-service","text":"No. At my previous employer we did build a PaaS on top of this architecture and this worked very well. However, Rebar is not a PaaS. Use your own PaaS, CloudFoundry, whatever. We are pretty sure that not ALL of your infrastructure will be in the PaaS though.","title":"Is it a Platform-as-a-Service?"},{"location":"faq/#is-it-an-asset-management-discovery-tool","text":"Asset management tools suck. When developers hear the words asset management they flee. Rebar is fun and cool. Rebar does do many of the things that asset management tools do but it is shiny new and modern and your dev team will love working with it.","title":"Is it an asset management / discovery tool?"},{"location":"faq/#why-do-i-need-this-graph-data-model-when-there-is-an-api-for-everything","text":"It is a good question. At small scale, tying things together with API calls works fine. But as soon as your infrastructure has enough dimensions (enivronments, teams, providers, services, etc.) even seemingly simple tasks can start to get quite complicated. I want to deploy a new version of XYZ to https://cool.example.com, but what account/region is it in? Which ELB handles it? Yes, these answers can be had with API calls. But in practice, it is surprisingly difficult. You start running into N^2 problems and/or running up against mundane problems like managing auth credentials for all your tools/scripts. Things become just difficult enough that neglect sets in. On the other hand, if you can get a real-time answer with a simple query against a graph database, problems that might have been daunting can seem almost effortless (and fun).","title":"Why do I need this graph data model when there is an API for everything?"},{"location":"faq/#im-using-awsgcpazure-why-would-i-need-this","text":"Your infrastructure is likely spread across many accounts and segmented into regions. Cloud providers do this to maximize availability and isolate regions into idependent failure domains. However, that comes at a cost of significant management complexity. You think you have infrastructure running in us-east-1 and us-west-2 . But do you have anything in eu-west-2 ? Are you sure? Does XYZ run in GCP or AWS or both? These are the kind of simple questions that can be quite time consuming to answer. With Rebar, they are simple. To cite a simple example, in our experience, cloud providers tend to send notifications about infrastructure without much context. The following is common: \"Thanks for telling me that i-ab38d8273ff4 is about to die. But what account is it in? What region? What is it for? Who is responsible for it? What will happen when it is terminated?\" You're on your own. Easy to automate? Yes. But will you? Probably not.","title":"I'm using AWS/GCP/Azure, why would I need this?"},{"location":"faq/#im-using-terraformcloudformationetc-why-would-i-need-this","text":"I'm going to take wild guess and say that only some subset of your infrastructure is actually managed by Terraform or CloudFormation or whatever your management tool of choice. But which services are using them correctly? Which aren't? These are the questions we can answer quickly and easily with Rebar. Besides, how many people in your org actually understand that Terraform / CloudFormation you wrote? I'll be that it is a lot fewer than you think.","title":"I'm using Terraform/CloudFormation/etc, why would I need this?"},{"location":"faq/#im-using-kubernetes-why-would-i-need-this","text":"First, if you are running anything more than a PoC, you probably have a few Kubernetes clusters. You might have some OpenShift on-prem and some EKS clusters spread across accounts and regions. If you want find all the services that are using an image with a critical CVE, how are you going to do that without going on a spelunking exercise? Again, it is not that it is a hard problem to solve. In our experience, you just won't prioritize it, so you die a slow death of 1000 cuts. Rebar fixes this.","title":"I'm using Kubernetes, why would I need this?"},{"location":"faq/#but-i-have-chefpuppetansiblesalt-why-would-i-need-this","text":"That's funny. In our experience, we needed Rebar just to figure out whether those tools were deployed and working correctly.","title":"But I have Chef/Puppet/Ansible/Salt, why would I need this?"},{"location":"getting-started/","text":"TBD","title":"Getting Started"},{"location":"kubernetes-model/","text":"Data Model KubeCluster Name Type Description clusterId string Kubernetes Cluster Id buildDate number compiler string gitCommit string gitTreeState string gitVersion string goVersion string graphEntityGroup string graphEntityType string graphUpdateTs number major string masterUrl string minor string platform string KubeContainer Name Type Description clusterId string Kubernetes Cluster Id name string Kubernetes Container Name containerID string graphEntityGroup string graphEntityType string graphUpdateTs number image string imageID string podUid string ready boolean restartCount number startedAt string KubeDaemonSet Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes DaemonSet Name namespace string Kubernetes DaemonSet Namespace uid string Kubernetes UID apiVersion string Kubernetes API Version creationTimestamp string creationTs number graphEntityGroup string graphEntityType string graphUpdateTs number resourceVersion string Kubernetes Resource Version selfLink string Kubernetes API server resource path generation NUMBER label_tier STRING label_addonmanager.kubernetes.io/mode STRING annotation_deprecated.daemonset.template.generation STRING annotation_aks.microsoft.com/release-time STRING annotation_kubectl.kubernetes.io/last-applied-configuration STRING label_component STRING label_kubernetes.io/cluster-service STRING KubeDeployment Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes Deployment Name namespace string Kubernetes Deployment Namespace uid string Kubernetes UID apiVersion string Kubernetes API Version availableReplicas number creationTimestamp string creationTs number graphEntityGroup string graphEntityType string graphUpdateTs number observedGeneration number replicas number resourceVersion string Kubernetes Resource Version selfLink string Kubernetes API server resource path updatedReplicas number label_version STRING label_k8s-app STRING label_component STRING label_app STRING generation NUMBER label_tier STRING label_addonmanager.kubernetes.io/mode STRING annotation_deployment.kubernetes.io/revision STRING annotation_kubectl.kubernetes.io/last-applied-configuration STRING label_kubernetes.io/cluster-service STRING KubeNamespace Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes Namespace Name uid string Kubernetes UID apiVersion string Kubernetes API Version creationTimestamp string creationTs number finalizers array graphEntityGroup string graphEntityType string graphUpdateTs number phase string resourceVersion string Kubernetes Resource Version selfLink string Kubernetes API server resource path annotation_kubectl.kubernetes.io/last-applied-configuration STRING KubeNode Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes Node Name uid string Kubernetes UID allocatable_cpu string allocatable_ephemeral-storage string allocatable_hugepages-1Gi string allocatable_hugepages-2Mi string allocatable_memory string allocatable_pods string apiVersion string Kubernetes API Version capacity_cpu string capacity_ephemeral-storage string capacity_hugepages-1Gi string capacity_hugepages-2Mi string capacity_memory string capacity_pods string creationTimestamp string creationTs number graphEntityGroup string graphEntityType string graphUpdateTs number resourceVersion string Kubernetes Resource Version selfLink string Kubernetes API server resource path label_kubernetes.io/hostname STRING label_kubernetes.azure.com/cluster STRING label_beta.kubernetes.io/instance-type STRING label_storagetier STRING annotation_volumes.kubernetes.io/controller-managed-attach-detach STRING label_failure-domain.beta.kubernetes.io/zone STRING label_kubernetes.io/role STRING label_beta.kubernetes.io/arch STRING label_failure-domain.beta.kubernetes.io/region STRING label_agentpool STRING label_storageprofile STRING annotation_node.alpha.kubernetes.io/ttl STRING label_beta.kubernetes.io/os STRING KubePod Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes Pod Name namespace string Kubernetes Pod Namespace uid string Kubernetes UID apiVersion string Kubernetes API Version creationTimestamp string creationTs number dnsPolicy string generateName string graphEntityGroup string graphEntityType string graphUpdateTs number hostIP string hostNetwork boolean nodeName string daemonSetUid string replicaSetUid string phase string podIP string priority number qosClass string resourceVersion string Kubernetes Resource Version restartPolicy string schedulerName string selfLink string Kubernetes API server resource path serviceAccount string serviceAccountName string startTime string terminationGracePeriodSeconds number annotation_WSID STRING annotation_agentVersion STRING label_version STRING label_k8s-app STRING label_component STRING label_app STRING label_pod-template-generation STRING label_tier STRING annotation_dockerProviderVersion STRING label_pod-template-hash STRING annotation_aks.microsoft.com/release-time STRING label_rsName STRING label_kubernetes.io/cluster-service STRING label_controller-revision-hash STRING KubeReplicaSet Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes ReplicaSet Name namespace string Kubernetes ReplicaSet Namespace uid string Kubernetes UID apiVersion string Kubernetes API Version creationTimestamp string creationTs number graphEntityGroup string graphEntityType string graphUpdateTs number deploymentUid string resourceVersion string Kubernetes Resource Version selfLink string Kubernetes API server resource path status_availableReplicas number status_fullyLabeledReplicas number status_observedGeneration number status_readyReplicas number status_replicas number annotation_deployment.kubernetes.io/max-replicas STRING label_version STRING label_k8s-app STRING label_component STRING label_app STRING generation NUMBER annotation_deployment.kubernetes.io/revision STRING label_pod-template-hash STRING label_rsName STRING label_kubernetes.io/cluster-service STRING annotation_deployment.kubernetes.io/desired-replicas STRING KubeService Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes Service Name namespace string Kubernetes Service Namespace uid string Kubernetes UID apiVersion string Kubernetes API Version clusterIP string clusterIpPort_TCP_ number clusterIpPort_TCP_443 number clusterIpPort_TCP_53 number clusterIpPort_TCP_8080 number clusterIpPort_TCP_8082 number clusterIpPort_TCP_dns-tcp number clusterIpPort_TCP_http number clusterIpPort_TCP_https number clusterIpPort_UDP_53 number clusterIpPort_UDP_dns number creationTimestamp string creationTs number externalTrafficPolicy string graphEntityGroup string graphEntityType string graphUpdateTs number healthCheckNodePort number nodePort_TCP_http number nodePort_TCP_https number podRef array resourceVersion string Kubernetes Resource Version selector_app string selector_k8s-app string selfLink string Kubernetes API server resource path sessionAffinity string type string label_kubernetes.io/name STRING label_k8s-app STRING label_component STRING label_app STRING label_addonmanager.kubernetes.io/mode STRING label_provider STRING annotation_kubectl.kubernetes.io/last-applied-configuration STRING label_kubernetes.io/cluster-service STRING","title":"Kubernetes Data Model"},{"location":"kubernetes-model/#data-model","text":"","title":"Data Model"},{"location":"kubernetes-model/#kubecluster","text":"Name Type Description clusterId string Kubernetes Cluster Id buildDate number compiler string gitCommit string gitTreeState string gitVersion string goVersion string graphEntityGroup string graphEntityType string graphUpdateTs number major string masterUrl string minor string platform string","title":"KubeCluster"},{"location":"kubernetes-model/#kubecontainer","text":"Name Type Description clusterId string Kubernetes Cluster Id name string Kubernetes Container Name containerID string graphEntityGroup string graphEntityType string graphUpdateTs number image string imageID string podUid string ready boolean restartCount number startedAt string","title":"KubeContainer"},{"location":"kubernetes-model/#kubedaemonset","text":"Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes DaemonSet Name namespace string Kubernetes DaemonSet Namespace uid string Kubernetes UID apiVersion string Kubernetes API Version creationTimestamp string creationTs number graphEntityGroup string graphEntityType string graphUpdateTs number resourceVersion string Kubernetes Resource Version selfLink string Kubernetes API server resource path generation NUMBER label_tier STRING label_addonmanager.kubernetes.io/mode STRING annotation_deprecated.daemonset.template.generation STRING annotation_aks.microsoft.com/release-time STRING annotation_kubectl.kubernetes.io/last-applied-configuration STRING label_component STRING label_kubernetes.io/cluster-service STRING","title":"KubeDaemonSet"},{"location":"kubernetes-model/#kubedeployment","text":"Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes Deployment Name namespace string Kubernetes Deployment Namespace uid string Kubernetes UID apiVersion string Kubernetes API Version availableReplicas number creationTimestamp string creationTs number graphEntityGroup string graphEntityType string graphUpdateTs number observedGeneration number replicas number resourceVersion string Kubernetes Resource Version selfLink string Kubernetes API server resource path updatedReplicas number label_version STRING label_k8s-app STRING label_component STRING label_app STRING generation NUMBER label_tier STRING label_addonmanager.kubernetes.io/mode STRING annotation_deployment.kubernetes.io/revision STRING annotation_kubectl.kubernetes.io/last-applied-configuration STRING label_kubernetes.io/cluster-service STRING","title":"KubeDeployment"},{"location":"kubernetes-model/#kubenamespace","text":"Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes Namespace Name uid string Kubernetes UID apiVersion string Kubernetes API Version creationTimestamp string creationTs number finalizers array graphEntityGroup string graphEntityType string graphUpdateTs number phase string resourceVersion string Kubernetes Resource Version selfLink string Kubernetes API server resource path annotation_kubectl.kubernetes.io/last-applied-configuration STRING","title":"KubeNamespace"},{"location":"kubernetes-model/#kubenode","text":"Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes Node Name uid string Kubernetes UID allocatable_cpu string allocatable_ephemeral-storage string allocatable_hugepages-1Gi string allocatable_hugepages-2Mi string allocatable_memory string allocatable_pods string apiVersion string Kubernetes API Version capacity_cpu string capacity_ephemeral-storage string capacity_hugepages-1Gi string capacity_hugepages-2Mi string capacity_memory string capacity_pods string creationTimestamp string creationTs number graphEntityGroup string graphEntityType string graphUpdateTs number resourceVersion string Kubernetes Resource Version selfLink string Kubernetes API server resource path label_kubernetes.io/hostname STRING label_kubernetes.azure.com/cluster STRING label_beta.kubernetes.io/instance-type STRING label_storagetier STRING annotation_volumes.kubernetes.io/controller-managed-attach-detach STRING label_failure-domain.beta.kubernetes.io/zone STRING label_kubernetes.io/role STRING label_beta.kubernetes.io/arch STRING label_failure-domain.beta.kubernetes.io/region STRING label_agentpool STRING label_storageprofile STRING annotation_node.alpha.kubernetes.io/ttl STRING label_beta.kubernetes.io/os STRING","title":"KubeNode"},{"location":"kubernetes-model/#kubepod","text":"Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes Pod Name namespace string Kubernetes Pod Namespace uid string Kubernetes UID apiVersion string Kubernetes API Version creationTimestamp string creationTs number dnsPolicy string generateName string graphEntityGroup string graphEntityType string graphUpdateTs number hostIP string hostNetwork boolean nodeName string daemonSetUid string replicaSetUid string phase string podIP string priority number qosClass string resourceVersion string Kubernetes Resource Version restartPolicy string schedulerName string selfLink string Kubernetes API server resource path serviceAccount string serviceAccountName string startTime string terminationGracePeriodSeconds number annotation_WSID STRING annotation_agentVersion STRING label_version STRING label_k8s-app STRING label_component STRING label_app STRING label_pod-template-generation STRING label_tier STRING annotation_dockerProviderVersion STRING label_pod-template-hash STRING annotation_aks.microsoft.com/release-time STRING label_rsName STRING label_kubernetes.io/cluster-service STRING label_controller-revision-hash STRING","title":"KubePod"},{"location":"kubernetes-model/#kubereplicaset","text":"Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes ReplicaSet Name namespace string Kubernetes ReplicaSet Namespace uid string Kubernetes UID apiVersion string Kubernetes API Version creationTimestamp string creationTs number graphEntityGroup string graphEntityType string graphUpdateTs number deploymentUid string resourceVersion string Kubernetes Resource Version selfLink string Kubernetes API server resource path status_availableReplicas number status_fullyLabeledReplicas number status_observedGeneration number status_readyReplicas number status_replicas number annotation_deployment.kubernetes.io/max-replicas STRING label_version STRING label_k8s-app STRING label_component STRING label_app STRING generation NUMBER annotation_deployment.kubernetes.io/revision STRING label_pod-template-hash STRING label_rsName STRING label_kubernetes.io/cluster-service STRING annotation_deployment.kubernetes.io/desired-replicas STRING","title":"KubeReplicaSet"},{"location":"kubernetes-model/#kubeservice","text":"Name Type Description clusterId string Kubernetes Cluster Id kind string Kubernetes type ( Pod , Deployment , etc.) name string Kubernetes Service Name namespace string Kubernetes Service Namespace uid string Kubernetes UID apiVersion string Kubernetes API Version clusterIP string clusterIpPort_TCP_ number clusterIpPort_TCP_443 number clusterIpPort_TCP_53 number clusterIpPort_TCP_8080 number clusterIpPort_TCP_8082 number clusterIpPort_TCP_dns-tcp number clusterIpPort_TCP_http number clusterIpPort_TCP_https number clusterIpPort_UDP_53 number clusterIpPort_UDP_dns number creationTimestamp string creationTs number externalTrafficPolicy string graphEntityGroup string graphEntityType string graphUpdateTs number healthCheckNodePort number nodePort_TCP_http number nodePort_TCP_https number podRef array resourceVersion string Kubernetes Resource Version selector_app string selector_k8s-app string selfLink string Kubernetes API server resource path sessionAffinity string type string label_kubernetes.io/name STRING label_k8s-app STRING label_component STRING label_app STRING label_addonmanager.kubernetes.io/mode STRING label_provider STRING annotation_kubectl.kubernetes.io/last-applied-configuration STRING label_kubernetes.io/cluster-service STRING","title":"KubeService"},{"location":"kubernetes/","text":"Launch Neo4j in Kubernetes Cluster You will need a neo4j instance to store the graph data. Assuming you don't have one available, the following will create a neo4j database instance as a pod inside your cluster: kubectl create -f \\ https://raw.githubusercontent.com/rebar-cloud/rebar-graph/master/rebar-scanner-kubernetes/neo4j.yaml Once the neo4j pod has started, you can expose the ports locally using kubectl port-forward so that you can use the neo4j browser to interact with the database: kubectl port-forward deployment/neo4j 7474 :7474 7687 :7687 Now you should be able to point your browser to http://localhost:7474 and use the neo4j console. Note: This neo4j instance is for demo purposes only. If the neo4j pod is restarted all data will be lost. Deploy rebar/kubernetes-scanner Now you should be able to schedule an instance of rebar/kubernetes-scanner inside your kubeernetes cluster. In this example, rebar will connect to the neo4j instance created above. kubectl create -f \\ https://raw.githubusercontent.com/rebar-cloud/rebar-graph/master/rebar-scanner-kubernetes/rebar.yaml Note: If you want to connect to a different neo4j instance, just set the GRAPH_URL environment property as you see fit. GRAPH_USERNAME and GRAPH_PASSWORD are supported options if your neo4j instance has auth enabled. Try It After a few seconds, rebar/kubernetes-scanner should have created a graph model of your cluster. Run the following locally: kubectl port-forward deployment/neo4j 7474 :7474 7687 :7687 And then point your browser to http://localhost:7474 . You should then be able to issue Cypher queries against your graph. To a have quick look at the whole graph: match (a) return a You can start looking at pieces of the graph: match (k:KubeCluster)--(n:KubeNamespace)--(d:KubeDeployment)--(rs:KubeReplicaSet)--(p:KubePod) return k,n,d,rs,p","title":"Kubernetes Scanner"},{"location":"kubernetes/#launch-neo4j-in-kubernetes-cluster","text":"You will need a neo4j instance to store the graph data. Assuming you don't have one available, the following will create a neo4j database instance as a pod inside your cluster: kubectl create -f \\ https://raw.githubusercontent.com/rebar-cloud/rebar-graph/master/rebar-scanner-kubernetes/neo4j.yaml Once the neo4j pod has started, you can expose the ports locally using kubectl port-forward so that you can use the neo4j browser to interact with the database: kubectl port-forward deployment/neo4j 7474 :7474 7687 :7687 Now you should be able to point your browser to http://localhost:7474 and use the neo4j console. Note: This neo4j instance is for demo purposes only. If the neo4j pod is restarted all data will be lost.","title":"Launch Neo4j in Kubernetes Cluster"},{"location":"kubernetes/#deploy-rebarkubernetes-scanner","text":"Now you should be able to schedule an instance of rebar/kubernetes-scanner inside your kubeernetes cluster. In this example, rebar will connect to the neo4j instance created above. kubectl create -f \\ https://raw.githubusercontent.com/rebar-cloud/rebar-graph/master/rebar-scanner-kubernetes/rebar.yaml Note: If you want to connect to a different neo4j instance, just set the GRAPH_URL environment property as you see fit. GRAPH_USERNAME and GRAPH_PASSWORD are supported options if your neo4j instance has auth enabled.","title":"Deploy rebar/kubernetes-scanner"},{"location":"kubernetes/#try-it","text":"After a few seconds, rebar/kubernetes-scanner should have created a graph model of your cluster. Run the following locally: kubectl port-forward deployment/neo4j 7474 :7474 7687 :7687 And then point your browser to http://localhost:7474 . You should then be able to issue Cypher queries against your graph. To a have quick look at the whole graph: match (a) return a You can start looking at pieces of the graph: match (k:KubeCluster)--(n:KubeNamespace)--(d:KubeDeployment)--(rs:KubeReplicaSet)--(p:KubePod) return k,n,d,rs,p","title":"Try It"}]}